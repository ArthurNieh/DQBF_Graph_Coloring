from blif_gen_random_graph_coloring import *

def hamiltonian_add_main_model(blif_lines, u_num):
### I/O parameters
    blif_lines.append(f".model random{u_num}\n")
    blif_lines.append(".inputs ")
    blif_lines.extend(f"u{i} " for i in range(u_num))
    blif_lines.extend(f"v{i} " for i in range(u_num))
    blif_lines.extend(f"c{i} " for i in range(u_num))
    blif_lines.extend(f"d{i} " for i in range(u_num))
    blif_lines.append("\n.outputs f\n")

### Graph subcircuit
    blif_lines.append(".subckt graph ")
    blif_lines.extend(f"U{i}=u{i} " for i in range(u_num))
    blif_lines.extend(f"V{i}=v{i} " for i in range(u_num))
    blif_lines.append("E=e0\n")

### c+1 = d
    ## const 1
    for i in range(u_num):
        blif_lines.append(f".names const{i}\n")
        if i == 0:
            blif_lines.append("1\n")
        else:
            blif_lines.append("0\n")
    blif_lines.append(f".subckt adder{u_num} ")
    blif_lines.extend(f"A{i}=c{i} " for i in range(u_num))
    blif_lines.extend(f"B{i}=const{i} " for i in range(u_num))
    blif_lines.extend(f"S{i}=cplus1{i} " for i in range(u_num))
    blif_lines.append("\n")

    blif_lines.append(f".subckt UequV{u_num} ")
    blif_lines.extend(f"U{i}=cplus1{i} " for i in range(u_num))
    blif_lines.extend(f"V{i}=d{i} " for i in range(u_num))
    blif_lines.append("O_equal=cplus1equald\n")

### u, v the same
    blif_lines.append(f".subckt UequV{u_num} ")
    blif_lines.extend(f"U{i}=u{i} " for i in range(u_num))
    blif_lines.extend(f"V{i}=v{i} " for i in range(u_num))
    blif_lines.append("O_equal=uvsame\n")

### c, d the same
    blif_lines.append(f".subckt UequV{u_num} ")
    blif_lines.extend(f"U{i}=c{i} " for i in range(u_num))
    blif_lines.extend(f"V{i}=d{i} " for i in range(u_num))
    blif_lines.append("O_equal=cdsame\n")

### Break symmetry u = 0 -> c = 0
    blif_lines.append(f".subckt is_zero ")
    blif_lines.extend(f"I{i}=u{i} " for i in range(u_num))
    blif_lines.append("O=uiszero\n")

    blif_lines.append(f".subckt is_zero ")
    blif_lines.extend(f"I{i}=c{i} " for i in range(u_num))
    blif_lines.append("O=ciszero\n")

    blif_lines.append(f".subckt imply I0=uiszero I1=ciszero O=uc0\n")

### main output f
    blif_lines.append(".subckt imply I0=cplus1equald I1=e0 O=sequence\n")
    blif_lines.append(".subckt equiv I0=uvsame I1=cdsame O=uvcdsame\n")
    blif_lines.append(".subckt and2 I0=sequence I1=uvcdsame O=fi\n")
    blif_lines.append(".subckt and2 I0=fi I1=uc0 O=f\n")

    blif_lines.append(".end\n\n")

    return

def hamiltonian_add_subcircuit(blif_lines, u_num):
    add_or_num(blif_lines, 2)
    add_and_num(blif_lines, 2)
    add_imply_gate(blif_lines)
    add_equiv_gate(blif_lines)
    add_nequiv_gate(blif_lines)
    add_UequivV(blif_lines, u_num)
    add_n_adder(blif_lines, u_num)
    add_is_0(blif_lines, u_num)

    return

if __name__ == "__main__":

    parser = argparse.ArgumentParser(description="Generate blif file for random graph with k-hamiltonian constraints.")
    parser.add_argument('-n', type=int, help='Number of nodes = 2^n (required)', required=True)
    parser.add_argument('-t', type=int, help='Trial number (for random graph generation)', default=0)
    parser.add_argument('--gen_graph', action='store_true', help='Generate implicit graph blif file')
    args = parser.parse_args()

    u_num = args.n
    trial = args.t

    graph_file = f"./graphs/random_graph_n{u_num}_trial{trial}.csv"

    output_blif_file = f"./sample/random_graph_hamiltonian_n{u_num}_trial{trial}.blif"
    output_graph_file = f"./graphs/random_graph_n{u_num}_trial{trial}_graph.blif"

    blif_lines = []

    # parse blif file generated by abc
    hamiltonian_add_main_model(blif_lines, u_num)
    add_simple_implicit_graph(blif_lines, graph_file, u_num, output_graph_file)
    if args.gen_graph:
        exit(0)
    hamiltonian_add_subcircuit(blif_lines, u_num)

    print("\nWriting blif file...")
    with open(output_blif_file, "w") as f:
        f.writelines(blif_lines)
    print("\nGenerate blif file successfully!\n")