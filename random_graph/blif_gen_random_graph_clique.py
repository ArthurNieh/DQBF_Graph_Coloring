from blif_gen_random_graph_coloring import *

def clique_add_main_model(blif_lines, u_num, k_digit_num):
### I/O parameters
    blif_lines.append(f".model random{u_num}\n")
    blif_lines.append(".inputs ")
    blif_lines.extend(f"i{i} " for i in range(k_digit_num))
    blif_lines.extend(f"j{i} " for i in range(k_digit_num))
    blif_lines.extend(f"u{i} " for i in range(u_num))
    blif_lines.extend(f"v{i} " for i in range(u_num))
    blif_lines.append("\n.outputs f\n")

### Graph subcircuit
    blif_lines.append(".subckt graph ")
    blif_lines.extend(f"U{i}=u{i} " for i in range(u_num))
    blif_lines.extend(f"V{i}=v{i} " for i in range(u_num))
    blif_lines.append("E=e0\n")

### u, v the same
    blif_lines.append(f".subckt UequV{u_num} ")
    blif_lines.extend(f"U{i}=u{i} " for i in range(u_num))
    blif_lines.extend(f"V{i}=v{i} " for i in range(u_num))
    blif_lines.append("O_equal=uvsame\n")

### i, j the same
    blif_lines.append(f".subckt UequV{k_digit_num} ")
    blif_lines.extend(f"U{i}=i{i} " for i in range(k_digit_num))
    blif_lines.extend(f"V{i}=j{i} " for i in range(k_digit_num))
    blif_lines.append("O_equal=ijsame\n")

### i, j nequal (not ij same)
    blif_lines.append(f".subckt not ")
    blif_lines.append("I=ijsame O=ijnequal\n")

### i, j < k
    blif_lines.append(f".subckt fit_color_limit ")
    blif_lines.extend(f"I{i}=i{i} " for i in range(k_digit_num))
    blif_lines.append("G=ifit\n")

    blif_lines.append(f".subckt fit_color_limit ")
    blif_lines.extend(f"I{i}=j{i} " for i in range(k_digit_num))
    blif_lines.append("G=jfit\n")
    
    blif_lines.append(".subckt and2 I0=ifit I1=jfit O=ijfit\n")

### main output f
    blif_lines.append(".subckt imply I0=ijnequal I1=e0 O=phi1\n")

    blif_lines.append(f".subckt equiv I0=ijsame I1=uvsame O=phi2\n")

    blif_lines.append(f".subckt and2 I0=phi1 I1=phi2 O=phi\n")
    blif_lines.append(f".subckt imply I0=ijfit I1=phi O=f\n")

    blif_lines.append(".end\n\n")

    return

def clique_add_subcircuit(blif_lines, u_num, k_digit_num):
    add_not_gate(blif_lines)
    add_or_num(blif_lines, 2)
    add_and_num(blif_lines, 2)
    add_imply_gate(blif_lines)
    add_equiv_gate(blif_lines)
    add_nequiv_gate(blif_lines)# xor2
    add_UequivV(blif_lines, u_num)
    add_UequivV(blif_lines, k_digit_num)

    return

if __name__ == "__main__":

    parser = argparse.ArgumentParser(description="Generate blif file for random graph with k-clique constraints.")
    parser.add_argument('-n', type=int, help='Number of nodes = 2^n (required)', required=True)
    parser.add_argument('-k', type=int, help='K (required)', default=3)
    parser.add_argument('-t', type=int, help='Trial number (for random graph generation)', default=0)
    parser.add_argument('--gen_graph', action='store_true', help='Generate implicit graph blif file')
    args = parser.parse_args()

    u_num = args.n
    k = args.k
    k_digit_num = math.ceil(math.log2(k))
    trial = args.t

    graph_file = f"./graphs/random_graph_n{u_num}_trial{trial}.csv"

    output_blif_file = f"./sample/random_graph_clique_n{u_num}_k{k}_trial{trial}.blif"
    output_graph_file = f"./graphs/random_graph_n{u_num}_trial{trial}_graph.blif"

    blif_lines = []

    # parse blif file generated by abc
    clique_add_main_model(blif_lines, u_num, k_digit_num)
    add_simple_implicit_graph(blif_lines, graph_file, u_num, output_graph_file)
    if args.gen_graph:
        exit(0)
    
    if k_digit_num > 1:
        add_fit_color_limit(blif_lines, k, k_digit_num)
    clique_add_subcircuit(blif_lines, u_num, k_digit_num)
    
    print("\nWriting blif file...")
    with open(output_blif_file, "w") as f:
        f.writelines(blif_lines)
    print(f"K: {k}-clique")
    print("\nGenerate blif file successfully!\n")